# -*- coding: utf-8 -*-
"""tarea_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14nOZCTAvOzIJWvCJXuWpaNSzMe6TkD5p
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import cv2
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
#from google.colab.patches import cv2_imshow

#%matplotlib inline
#from ipywidgets import interact, widgets

#try:
#    import google.colab
#    IN_COLAB = True
#except:
#    IN_COLAB = False

#if IN_COLAB:
#    !git clone https://github.com/felipesanmartin/TutorialCV.git
#    root = 'TutorialCV/'
#    from TutorialCV.hist_3d import Hist3D
#    from google.colab.patches import cv2_imshow
#else:
#    root = ''
#    from hist_3d import Hist3D
#    cv2_imshow = cv2.imshow

#sldr = lambda v, mi, ma, st: widgets.FloatSlider(
#    value=v,
#    min=mi,
#    max=ma,
#    step=st,
#    continuous_update=False
#)

img_logo = cv2.imread('patopato.jpg', cv2.IMREAD_GRAYSCALE)
img_imprimir = cv2.imread('patopato.jpg')
img_imprimir = cv2.cvtColor(img_imprimir, cv2.COLOR_BGR2RGB)

def f(t1, t2):

    t1 = int(t1)
    t2 = int(t2)
    image_out = cv2.Canny(img_logo,t1,t2)
    fig = plt.figure(figsize = (10,10))
    plt.imshow(image_out, vmin = 0, vmax = 255, cmap='gray')

#interact(f, **{'t1':sldr(50, 50, 255, 1), 't2':sldr(50, 50, 255, 1)})

im_color = cv2.imread('patopato.jpg', cv2.IMREAD_COLOR)
im_gray = cv2.cvtColor(im_color, cv2.COLOR_BGR2GRAY)


_, mask = cv2.threshold(im_gray, thresh=180, maxval=255, type=cv2.THRESH_BINARY)
#im_thresh_gray = cv2.bitwise_and(im_gray, mask)

mask3 = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)

im_thresh_color = cv2.bitwise_and(im_color, mask3)


cv2.waitKey(0)





img_owo = cv2.cvtColor(im_thresh_color, cv2.COLOR_BGR2GRAY)

img_canny = cv2.Canny(img_owo, 30, 200)

kernel = np.ones((3,3),np.uint8) 
img_out_dilate = cv2.dilate(img_canny, kernel, iterations = 1)


#img_owo = cv2.cvtColor(im_thresh_color, cv2.COLOR_BGR2GRAY)

#img_canny = cv2.Canny(img_owo, 30, 200)




#codigo anterior
contours, hierarchy = cv2.findContours(img_out_dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

def contour_area(contours):
     
    # create an empty list
    cnt_area = []
     
    # loop through all the contours
    for i in range(0,len(contours),1):
        # for each contour, use OpenCV to calculate the area of the contour
        cnt_area.append(cv2.contourArea(contours[i]))
 
    # Sort our list of contour areas in descending order
    list.sort(cnt_area, reverse=True)
    return cnt_area

def draw_bounding_box(contours, image, number_of_boxes= 2):
    # Call our function to get the list of contour areas
    cnt_area = contour_area(contours)
 
    # Loop through each contour of our image
    for i in range(0,len(contours),1):
        cnt = contours[i]
 
        # Only draw the the largest number of boxes
        if (cv2.contourArea(cnt) >= cnt_area[number_of_boxes]):
             
            # Use OpenCV boundingRect function to get the details of the contour
            x,y,w,h = cv2.boundingRect(cnt)
             
            # Draw the bounding box
            image=cv2.rectangle(image,(x,y),(x+w,y+h),(0,255,0),2)
 
    return image

print("Number of Contours found = " + str(len(contours)))

img_imprimir_2 = draw_bounding_box(contours, img_imprimir)
#plt.imshow(img_imprimir_2, vmin = 0, vmax = 255, cmap='gray')
#plt.show()

img_owo = cv2.cvtColor(img_imprimir, cv2.COLOR_BGR2GRAY)

img_canny = cv2.Canny(img_owo, 30, 200)
cv2.waitKey(0)

contours, hierarchy = cv2.findContours(img_out_dilate, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

#plt.imshow(img_canny.copy(), vmin = 0, vmax = 255, cmap='gray')

#cv2.imshow('Canny Edges After Contouring', chao)

cv2.waitKey(0)

print("Number of Contours found = " + str(len(contours)))

cv2.drawContours(img_imprimir, contours, -1, (0,255, 0), 3)

#cv2_imshow(img_imprimir)

#cv2.imshow('Contours', img_imprimir)

#plt.imshow(img_imprimir, vmin = 0, vmax = 255, cmap='gray')

#cv2.waitKey(0)
#cv2.destroyAllWindows()

x,y,w,h = cv2.boundingRect(contours[0])
cv2.rectangle(img_imprimir,(x,y),(x+w,y+h),(0,255,0),3)

#plt.imshow(img_imprimir, vmin = 0, vmax = 255, cmap='gray')
#plt.show()

#cv2_imshow(img_imprimir)
#cv2.imshow("result",image)
cv2.waitKey(0)
cv2.destroyAllWindows()

x = 0
while x <= 250:
    x=x+1
    lista=img_out_dilate[:, x]
    a=0
    while a<=175:
      a=a+1
      if int(lista[a])!=0:
        print("pato encontrado!", x, a)
        uno=x
        break
    if int(lista[a])!=0:
      break

x = 250
while x >= 0:
    x=x-1
    lista=img_out_dilate[:, x]
    a=0
    while a<=175:
      a=a+1
      if int(lista[a])!=0:
        print("pato encontrado!", x, a)
        dos=x
        break
    if int(lista[a])!=0:
      break

y = 0
while y <= 180:
    y=y+1
    lista=img_out_dilate[y, :]
    a=0
    while a<=175:
      a=a+1
      if int(lista[a])!=0:
        print("pato encontrado!", y, a)
        tres=y
        break
    if int(lista[a])!=0:
      break

y = 180
while y <= 180:
    y=y-1
    lista=img_out_dilate[y, :]
    a=0
    while a<=175:
      a=a+1
      if int(lista[a])!=0:
        print("pato encontrado!", y, a)
        cuatro=y
        break
    if int(lista[a])!=0:
      break

print("x mínimo=", uno, "x máximo=", dos, "y mínimo=", tres, "y máximo=", cuatro)

zz=cv2.rectangle(img_imprimir , (uno,tres), (dos,cuatro), color=(0,255,0), thickness=1)
plt.imshow(zz,vmin=0,vmax=255)

plt.show()